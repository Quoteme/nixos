From b4689d97a9039c3925d5c5dd4dd8bc4ba023cf6e Mon Sep 17 00:00:00 2001
From: Luca Leon Happel <lucahappel99@gmx.de>
Date: Fri, 9 Sep 2022 12:57:24 +0200
Subject: [PATCH 1/1] add parameter to borderresize

first attempt. might contain errors
---
 XMonad/Layout/BorderResize.hs | 49 ++++++++++++++++-------------------
 1 file changed, 23 insertions(+), 26 deletions(-)

diff --git a/XMonad/Layout/BorderResize.hs b/XMonad/Layout/BorderResize.hs
index 85ddfa88..043345be 100644
--- a/XMonad/Layout/BorderResize.hs
+++ b/XMonad/Layout/BorderResize.hs
@@ -58,27 +58,24 @@ data BorderInfo = BI { bWin :: Window,
 
 type RectWithBorders = (Rectangle, [BorderInfo])
 
-newtype BorderResize a = BR (M.Map Window RectWithBorders) deriving (Show, Read)
+data BorderResize a = BR Dimension (M.Map Window RectWithBorders) deriving (Show, Read)
 
-brBorderSize :: Dimension
-brBorderSize = 2
-
-borderResize :: l a -> ModifiedLayout BorderResize l a
-borderResize = ModifiedLayout (BR M.empty)
+borderResize :: Dimension -> l a -> ModifiedLayout BorderResize l a
+borderResize brBorderSize = ModifiedLayout (BR brBorderSize M.empty)
 
 instance LayoutModifier BorderResize Window where
     redoLayout _       _ Nothing  wrs = return (wrs, Nothing)
-    redoLayout (BR wrsLastTime) _ _ wrs = do
+    redoLayout (BR brBorderSize wrsLastTime) _ _ wrs = do
             let correctOrder = map fst wrs
                 wrsCurrent = M.fromList wrs
                 wrsGone = M.difference wrsLastTime wrsCurrent
                 wrsAppeared = M.difference wrsCurrent wrsLastTime
                 wrsStillThere = M.intersectionWith testIfUnchanged wrsLastTime wrsCurrent
             handleGone wrsGone
-            wrsCreated <- handleAppeared wrsAppeared
-            let wrsChanged = handleStillThere wrsStillThere
+            wrsCreated <- handleAppeared brBorderSize wrsAppeared
+            let wrsChanged = handleStillThere brBorderSize wrsStillThere
                 wrsThisTime = M.union wrsChanged wrsCreated
-            return (compileWrs wrsThisTime correctOrder, Just $ BR wrsThisTime)
+            return (compileWrs wrsThisTime correctOrder, Just $ BR brBorderSize wrsThisTime)
             -- What we return is the original wrs with the new border
             -- windows inserted at the correct positions - this way, the core
             -- will restack the borders correctly.
@@ -91,11 +88,11 @@ instance LayoutModifier BorderResize Window where
                     then (Nothing, entry)
                     else (Just rCurrent, entry)
 
-    handleMess (BR wrsLastTime) m
+    handleMess (BR brBorderSize wrsLastTime) m
         | Just e <- fromMessage m :: Maybe Event =
             handleResize (createBorderLookupTable wrsLastTime) e >> return Nothing
         | Just _ <- fromMessage m :: Maybe LayoutMessages =
-            handleGone wrsLastTime >> return (Just $ BR M.empty)
+            handleGone wrsLastTime >> return (Just $ BR brBorderSize M.empty)
     handleMess _ _ = return Nothing
 
 compileWrs :: M.Map Window RectWithBorders -> [Window] -> [(Window, Rectangle)]
@@ -112,26 +109,26 @@ handleGone wrsGone = mapM_ deleteWindow borderWins
     where
         borderWins = map bWin . concatMap snd . M.elems $ wrsGone
 
-handleAppeared :: M.Map Window Rectangle -> X (M.Map Window RectWithBorders)
-handleAppeared wrsAppeared = do
+handleAppeared :: Dimension -> M.Map Window Rectangle -> X (M.Map Window RectWithBorders)
+handleAppeared brBorderSize wrsAppeared = do
     let wrs = M.toList wrsAppeared
-    wrsCreated <- mapM handleSingleAppeared wrs
+    wrsCreated <- mapM (handleSingleAppeared brBorderSize) wrs
     return $ M.fromList wrsCreated
 
-handleSingleAppeared :: (Window, Rectangle) -> X (Window, RectWithBorders)
-handleSingleAppeared (w, r) = do
-    let borderBlueprints = prepareBorders r
+handleSingleAppeared :: Dimension -> (Window, Rectangle) -> X (Window, RectWithBorders)
+handleSingleAppeared brBorderSize (w, r) = do
+    let borderBlueprints = prepareBorders brBorderSize r
     borderInfos <- mapM createBorder borderBlueprints
     return (w, (r, borderInfos))
 
-handleStillThere :: M.Map Window (Maybe Rectangle, RectWithBorders) -> M.Map Window RectWithBorders
-handleStillThere = M.map handleSingleStillThere
+handleStillThere :: Dimension -> M.Map Window (Maybe Rectangle, RectWithBorders) -> M.Map Window RectWithBorders
+handleStillThere brBorderSize = M.map (handleSingleStillThere brBorderSize)
 
-handleSingleStillThere :: (Maybe Rectangle, RectWithBorders) -> RectWithBorders
-handleSingleStillThere (Nothing, entry) = entry
-handleSingleStillThere (Just rCurrent, (_, borderInfos)) = (rCurrent, updatedBorderInfos)
+handleSingleStillThere :: Dimension -> (Maybe Rectangle, RectWithBorders) -> RectWithBorders
+handleSingleStillThere brBorderSize (Nothing, entry) = entry
+handleSingleStillThere brBorderSize (Just rCurrent, (_, borderInfos)) = (rCurrent, updatedBorderInfos)
     where
-        changedBorderBlueprints = prepareBorders rCurrent
+        changedBorderBlueprints = prepareBorders brBorderSize rCurrent
         updatedBorderInfos = zipWith (curry updateBorderInfo) borderInfos changedBorderBlueprints
           -- assuming that the four borders are always in the same order
 
@@ -144,8 +141,8 @@ createBorderLookupTable wrsLastTime = concatMap processSingleEntry (M.toList wrs
         processSingleEntry :: (Window, RectWithBorders) -> [(Window, (BorderType, Window, Rectangle))]
         processSingleEntry (w, (r, borderInfos)) = for borderInfos $ \bi -> (bWin bi, (bType bi, w, r))
 
-prepareBorders :: Rectangle -> [BorderBlueprint]
-prepareBorders (Rectangle x y wh ht) =
+prepareBorders :: Dimension -> Rectangle -> [BorderBlueprint]
+prepareBorders brBorderSize (Rectangle x y wh ht) =
     [(Rectangle (x + fi wh - fi brBorderSize) y brBorderSize ht, xC_right_side , RightSideBorder),
      (Rectangle x y brBorderSize ht                            , xC_left_side  , LeftSideBorder),
      (Rectangle x y wh brBorderSize                            , xC_top_side   , TopSideBorder),
-- 
2.36.2

