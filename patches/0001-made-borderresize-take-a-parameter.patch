From 45faf3a27c29ecdef4997edbd60688206df50b7d Mon Sep 17 00:00:00 2001
From: Luca Leon Happel <lucahappel99@gmx.de>
Date: Fri, 9 Sep 2022 14:11:34 +0200
Subject: [PATCH 1/1] made borderresize take a parameter

the parameter is how many pixels near the border of a window resizing will be possible
---
 XMonad/Config/Bluetile.hs     |  2 +-
 XMonad/Layout/BorderResize.hs | 49 ++++++++++++++++-------------------
 2 files changed, 24 insertions(+), 27 deletions(-)

diff --git a/XMonad/Config/Bluetile.hs b/XMonad/Config/Bluetile.hs
index f39fdd17..96a24e22 100644
--- a/XMonad/Config/Bluetile.hs
+++ b/XMonad/Config/Bluetile.hs
@@ -188,7 +188,7 @@ bluetileLayoutHook = avoidStruts $ minimize $ boringWindows $
                         named "Tiled2" tiled2 |||
                         named "Fullscreen" fullscreen
         where
-            floating = floatingDeco $ maximize $ borderResize positionStoreFloat
+            floating = floatingDeco $ maximize $ (borderResize 3) positionStoreFloat
             tiled1 = tilingDeco $ maximize mouseResizableTileMirrored
             tiled2 = tilingDeco $ maximize mouseResizableTile
             fullscreen = tilingDeco $ maximize $ smartBorders Full
diff --git a/XMonad/Layout/BorderResize.hs b/XMonad/Layout/BorderResize.hs
index 85ddfa88..3e087e31 100644
--- a/XMonad/Layout/BorderResize.hs
+++ b/XMonad/Layout/BorderResize.hs
@@ -58,27 +58,24 @@ data BorderInfo = BI { bWin :: Window,
 
 type RectWithBorders = (Rectangle, [BorderInfo])
 
-newtype BorderResize a = BR (M.Map Window RectWithBorders) deriving (Show, Read)
+data BorderResize a = BR Dimension (M.Map Window RectWithBorders) deriving (Show, Read)
 
-brBorderSize :: Dimension
-brBorderSize = 2
-
-borderResize :: l a -> ModifiedLayout BorderResize l a
-borderResize = ModifiedLayout (BR M.empty)
+borderResize :: Dimension -> l a -> ModifiedLayout BorderResize l a
+borderResize brBorderSize = ModifiedLayout (BR brBorderSize M.empty)
 
 instance LayoutModifier BorderResize Window where
     redoLayout _       _ Nothing  wrs = return (wrs, Nothing)
-    redoLayout (BR wrsLastTime) _ _ wrs = do
+    redoLayout (BR brBorderSize wrsLastTime) _ _ wrs = do
             let correctOrder = map fst wrs
                 wrsCurrent = M.fromList wrs
                 wrsGone = M.difference wrsLastTime wrsCurrent
                 wrsAppeared = M.difference wrsCurrent wrsLastTime
                 wrsStillThere = M.intersectionWith testIfUnchanged wrsLastTime wrsCurrent
             handleGone wrsGone
-            wrsCreated <- handleAppeared wrsAppeared
-            let wrsChanged = handleStillThere wrsStillThere
+            wrsCreated <- handleAppeared brBorderSize wrsAppeared
+            let wrsChanged = handleStillThere brBorderSize wrsStillThere
                 wrsThisTime = M.union wrsChanged wrsCreated
-            return (compileWrs wrsThisTime correctOrder, Just $ BR wrsThisTime)
+            return (compileWrs wrsThisTime correctOrder, Just $ BR brBorderSize wrsThisTime)
             -- What we return is the original wrs with the new border
             -- windows inserted at the correct positions - this way, the core
             -- will restack the borders correctly.
@@ -91,11 +88,11 @@ instance LayoutModifier BorderResize Window where
                     then (Nothing, entry)
                     else (Just rCurrent, entry)
 
-    handleMess (BR wrsLastTime) m
+    handleMess (BR brBorderSize wrsLastTime) m
         | Just e <- fromMessage m :: Maybe Event =
             handleResize (createBorderLookupTable wrsLastTime) e >> return Nothing
         | Just _ <- fromMessage m :: Maybe LayoutMessages =
-            handleGone wrsLastTime >> return (Just $ BR M.empty)
+            handleGone wrsLastTime >> return (Just $ BR brBorderSize M.empty)
     handleMess _ _ = return Nothing
 
 compileWrs :: M.Map Window RectWithBorders -> [Window] -> [(Window, Rectangle)]
@@ -112,26 +109,26 @@ handleGone wrsGone = mapM_ deleteWindow borderWins
     where
         borderWins = map bWin . concatMap snd . M.elems $ wrsGone
 
-handleAppeared :: M.Map Window Rectangle -> X (M.Map Window RectWithBorders)
-handleAppeared wrsAppeared = do
+handleAppeared :: Dimension -> M.Map Window Rectangle -> X (M.Map Window RectWithBorders)
+handleAppeared brBorderSize wrsAppeared = do
     let wrs = M.toList wrsAppeared
-    wrsCreated <- mapM handleSingleAppeared wrs
+    wrsCreated <- mapM (handleSingleAppeared brBorderSize) wrs
     return $ M.fromList wrsCreated
 
-handleSingleAppeared :: (Window, Rectangle) -> X (Window, RectWithBorders)
-handleSingleAppeared (w, r) = do
-    let borderBlueprints = prepareBorders r
+handleSingleAppeared :: Dimension ->(Window, Rectangle) -> X (Window, RectWithBorders)
+handleSingleAppeared brBorderSize (w, r) = do
+    let borderBlueprints = prepareBorders brBorderSize r
     borderInfos <- mapM createBorder borderBlueprints
     return (w, (r, borderInfos))
 
-handleStillThere :: M.Map Window (Maybe Rectangle, RectWithBorders) -> M.Map Window RectWithBorders
-handleStillThere = M.map handleSingleStillThere
+handleStillThere :: Dimension -> M.Map Window (Maybe Rectangle, RectWithBorders) -> M.Map Window RectWithBorders
+handleStillThere brBorderSize = M.map (handleSingleStillThere brBorderSize)
 
-handleSingleStillThere :: (Maybe Rectangle, RectWithBorders) -> RectWithBorders
-handleSingleStillThere (Nothing, entry) = entry
-handleSingleStillThere (Just rCurrent, (_, borderInfos)) = (rCurrent, updatedBorderInfos)
+handleSingleStillThere :: Dimension -> (Maybe Rectangle, RectWithBorders) -> RectWithBorders
+handleSingleStillThere brBorderSize (Nothing, entry) = entry
+handleSingleStillThere brBorderSize (Just rCurrent, (_, borderInfos)) = (rCurrent, updatedBorderInfos)
     where
-        changedBorderBlueprints = prepareBorders rCurrent
+        changedBorderBlueprints = prepareBorders brBorderSize rCurrent
         updatedBorderInfos = zipWith (curry updateBorderInfo) borderInfos changedBorderBlueprints
           -- assuming that the four borders are always in the same order
 
@@ -144,8 +141,8 @@ createBorderLookupTable wrsLastTime = concatMap processSingleEntry (M.toList wrs
         processSingleEntry :: (Window, RectWithBorders) -> [(Window, (BorderType, Window, Rectangle))]
         processSingleEntry (w, (r, borderInfos)) = for borderInfos $ \bi -> (bWin bi, (bType bi, w, r))
 
-prepareBorders :: Rectangle -> [BorderBlueprint]
-prepareBorders (Rectangle x y wh ht) =
+prepareBorders :: Dimension -> Rectangle -> [BorderBlueprint]
+prepareBorders brBorderSize (Rectangle x y wh ht) =
     [(Rectangle (x + fi wh - fi brBorderSize) y brBorderSize ht, xC_right_side , RightSideBorder),
      (Rectangle x y brBorderSize ht                            , xC_left_side  , LeftSideBorder),
      (Rectangle x y wh brBorderSize                            , xC_top_side   , TopSideBorder),
-- 
2.36.2

